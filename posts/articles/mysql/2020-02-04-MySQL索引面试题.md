---
layout:     post
title:      MySQL索引面试题
category:   MySQL
tags:       ['MySQL索引']
description:   相信很多人对于MySQL的索引都不陌生，索引(Index)是帮助MySQL高效获取数据的数据结构。d因为索引是MySQL中比较重点的知识，相信很多人都有一定的了解，尤其是在面试中出现的频率特别高。楼主自认为自己对MySQL的索引相关知识有很多了解，而且因为最近在找工作面试，所以单独复习了很多关于索引的知识。
---

<div id="cnblogs_post_body" class="blogpost-body ">
    <p><strong>转载：https://mp.weixin.qq.com/s/_bk2JVOm2SkXfdcvki6-0w</strong></p>
<p><strong>本文来自一位不愿意透露姓名的粉丝投稿，由Hollis整理并"还原"了面试现场。</strong></p>
<p>相信很多人对于MySQL的索引都不陌生，索引(Index)是帮助MySQL高效获取数据的数据结构。</p>
<p>因为索引是MySQL中比较重点的知识，相信很多人都有一定的了解，尤其是在面试中出现的频率特别高。楼主自认为自己对MySQL的索引相关知识有很多了解，而且因为最近在找工作面试，所以单独复习了很多关于索引的知识。</p>
<p>但是，我还是图样图森破，直到我被阿里的面试官虐过之后我才知道，自己在索引方面的知识，只是个小学生水平。</p>
<p>以下，是我总结的一次阿里面试中关于索引有关的问题以及知识点。</p>
<p><strong>1</strong></p>
<p><strong><span>索引概念、索引模型</span></strong></p>
<p>我们是怎么聊到索引的呢，是因为我提到我们的业务量比较大，每天大概有几百万的新数据生成，于是有了以下对话：</p>
<p><strong>Q：</strong><strong>你们每天这么大的数据量，都是保存在关系型数据库中吗？</strong></p>
<p><strong>A：</strong>是的，我们线上使用的是MySQL数据库&nbsp;</p>
<p><strong>Q：</strong><strong>每天几百万数据，一个月就是几千万了，那你们有没有对于查询做一些优化呢？</strong></p>
<p><strong>A：</strong>我们在数据库中创建了一些索引（我现在非常后悔我当时说了这句话）</p>
<p>&nbsp;</p>
<p><span>这里可以看到，阿里的面试官并不会像有一些公司一样拿着题库一道一道的问，而是会根据面试者做过的事情以及面试过程中的一些内容进行展开。</span></p>
<p><strong>&nbsp;</strong></p>
<p><strong>Q：</strong><strong>那你能说说什么是索引吗？</strong></p>
<p><strong>A：</strong>（这道题肯定难不住我啊）索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据</p>
<p><strong>Q：</strong><strong>那么索引具体采用的哪种数据结构呢？&nbsp;</strong></p>
<p><strong>A：</strong>（这道题我也背过）常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树</p>
<p>&nbsp;</p>
<p><span>这里我耍了一个小心机，特意说了一下索引和存储引擎有关。希望面试官可以问我一些关于存储引擎的问题。然而面试官并没有被我带跑...</span></p>
<p>&nbsp;</p>
<p><strong>Q：</strong><strong>既然你提到InnoDB使用的B+ 树的索引模型，那么你知道为什么采用B+ 树吗？这和Hash索引比较起来有什么优缺点吗？</strong></p>
<p><strong>A：</strong>（突然觉得这道题有点难，但是我还是凭借着自己的知识储备简单的回答上一些）因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。<strong>所以，哈希索引只适用于等值查询的场景。</strong>而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</p>
<p><strong>Q：</strong><strong>除了上面这个范围查询的，你还能说出其他的一些区别吗？&nbsp;</strong></p>
<p><strong>A：</strong>（这个题我回答的不好，事后百度了一下）</p>
<p>&nbsp;</p>
<p>B+&nbsp;Tree索引和Hash索引区别？</p>
<p>哈希索引适合等值查询，但是无法进行范围查询&nbsp;</p>
<p>哈希索引没办法利用索引完成排序&nbsp;</p>
<p>哈希索引不支持多列联合索引的最左匹配规则&nbsp;</p>
<p>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</p>
<p>&nbsp;</p>
<p><strong>2</strong></p>
<p><strong><span>聚簇索引、覆盖索引</span></strong></p>
<p>&nbsp;</p>
<p><strong>Q：</strong><strong>刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？</strong></p>
<p><strong>A：</strong>InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值</p>
<p><strong>Q：</strong><strong>那这两者有什么区别吗？&nbsp;</strong></p>
<p><strong>A：</strong>（当他问我叶子节点的时候，其实我就猜到他可能要问我聚簇索引和非聚簇索引了）在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引</p>
<p><strong>Q：</strong><strong>那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？</strong></p>
<p><strong>A：</strong>聚簇索引查询会更快？</p>
<p><strong>Q：</strong><strong>为什么呢？&nbsp;</strong></p>
<p><strong>A：</strong>因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询</p>
<p><strong>Q：</strong><strong>刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做<strong>回表</strong>）是所有情况都是这样的吗？非主键索引一定会查询多次吗？</strong></p>
<p><strong>A：</strong>（额、这个问题我回答的不好，后来我自己查资料才知道，通过<strong>覆盖索引</strong>也可以只查询一次）</p>
<p>&nbsp;</p>
<p>覆盖索引？</p>
<p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。</p>
<p>当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。</p>
<p>如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。</p>
<p>当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。</p>
<p>&nbsp;</p>
<p><strong>3</strong></p>
<p><strong><span>联合索引、最左前缀匹配</span></strong></p>
<p>&nbsp;</p>
<p><strong>Q：</strong><strong>不知道的话没关系，想问一下，你们在创建索引的时候都会考虑哪些因素呢？</strong></p>
<p><strong>A：</strong>我们一般对于查询概率比较高，经常作为where条件的字段设置索引</p>
<p><strong>Q：</strong><strong>&nbsp;那你们有用过联合索引吗？&nbsp;</strong></p>
<p><strong>A：</strong>用过呀，我们有对一些表中创建过联合索引</p>
<p><strong>Q：</strong><strong>那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？&nbsp;</strong></p>
<p><strong>A：</strong>我们把识别度最高的字段放到最前面</p>
<p><strong>Q：</strong><strong>为什么这么做呢？</strong></p>
<p><strong>A：</strong>（这个问题有点把我问蒙了，稍微有些慌乱）这样的话可能命中率会高一点吧。。。</p>
<p><strong>Q：</strong><strong>&nbsp;那你知道最左前缀匹配吗？</strong></p>
<p><strong>A：</strong>（我突然想起来原来面试官是想问这个，怪自己刚刚为什么就没想到这个呢。）哦哦哦。您刚刚问的是这个意思啊，在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则</p>
<p>&nbsp;</p>
<p><span>虽然我一开始有点懵，没有联想到最左前缀匹配，但是面试官还是引导了我。很友善。</span></p>
<p>&nbsp;</p>
<p><strong>4</strong></p>
<p><strong><span>索引下推、查询优化</span></strong></p>
<p>&nbsp;</p>
<p><strong>Q：</strong><strong>你们线上用的MySQL是哪个版本啊呢？&nbsp;</strong></p>
<p><strong>A：</strong>我们MySQL是5.7&nbsp;</p>
<p><strong>Q：</strong><strong>那你知道在MySQL 5.6中，对索引做了哪些优化吗？&nbsp;</strong></p>
<p><strong>A：</strong>不好意思，这个我没有去了解过。（事后我查了一下，有一个比较重要的 ：Index Condition Pushdown Optimization）</p>
<p>&nbsp;</p>
<p>Index Condition Pushdown（索引下推）</p>
<p>MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = 'index_condition_pushdown=off';可以将其关闭。官方文档中给的例子和解释如下：</p>
<p>people表中（zipcode，lastname，firstname）构成一个索引</p>
<p>SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';</p>
<p>如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。</p>
<p>如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。</p>
<p><strong>Q：</strong><strong>你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？</strong></p>
<p><strong>A：</strong>这个还没有统计过，除非遇到慢SQL的时候我们才会去排查&nbsp;</p>
<p><strong>Q：</strong><strong>那排查的时候，有什么手段可以知道有没有走索引查询呢？</strong></p>
<p><strong>A：</strong>可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况</p>
<p><strong>Q：</strong><strong>那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？&nbsp;</strong></p>
<p><strong>A：</strong>（大概记得和优化器有关，但是这个问题并没有回答好）</p>
<p>&nbsp;</p>
<p>查询优化器？</p>
<p>一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。</p>
<p>在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。</p>
<p>这个成本最低的方案就是所谓的执行计划。优化过程大致如下：</p>
<p>1、根据搜索条件，找出所有可能使用的索引&nbsp;</p>
<p>2、计算全表扫描的代价&nbsp;</p>
<p>3、计算使用不同索引执行查询的代价&nbsp;</p>
<p>4、对比各种执行方案的代价，找出成本最低的那一个</p>
<p><strong>Q：</strong><strong>哦，索引有关的知识我们暂时就问这么多吧。你们线上数据的事务隔离级别是什么呀？&nbsp;</strong></p>
<p><strong>A：</strong>(后面关于事务隔离级别的问题了，就不展开了)</p>
<p>&nbsp;</p>
<p><span>感觉是因为我回答的不够好，如果这几个索引问题我都会的话，他还会追问更多，恐怕会被虐的更惨</span></p>
<p>&nbsp;</p>
<p><strong>5</strong></p>
<p><strong><span>总结&amp;感悟</span></strong></p>
<p>以上，就是一次面试中关于索引部分知识的问题以及我整理的答案。感觉这次面试过程中关于索引的知识，自己大概能够回答的内容占70%左右，但是自信完全答对的内容只占50%左右，看来自己索引有关的知识了解的还是不够多。</p>
<p>通过这次面试，发现像阿里这种大厂对于底层知识还是比较看重的，我以前以为关于索引最多也就问一下Hash和B+有什么区别，没想到最后都能问到查询优化器上面。</p>
<p><strong>最后，不管本次面试能不能通过，都非常感谢有这样一次机会，可以让自己看到自己的不足。通过这次面试，我也收获了很多东西。加油！</strong></p>
<p>参考资料：</p>
<p>极客时间 -《MySQL实战45讲》&nbsp;</p>
<p>掘金小册 -《MySQL 是怎样运行的：从根儿上理解 MySQL》&nbsp;</p>
<p>博文视点 -《高性能MySQL》</p>
<p>&nbsp;</p>
</div>